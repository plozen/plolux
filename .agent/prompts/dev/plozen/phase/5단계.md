# 5ë‹¨ê³„: ê³ ê¸‰ ê¸°ëŠ¥ êµ¬í˜„

## ğŸ¯ ë‹¨ê³„ ëª©í‘œ

íŒŒì¼ ì—…ë¡œë“œ, ì‹¤ì‹œê°„ ì•Œë¦¼, ì˜ˆì•½ ì‹œìŠ¤í…œ ë“± ê³ ê¸‰ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì—¬ í”Œë«í¼ì˜ ê²½ìŸë ¥ì„ ê°•í™”í•©ë‹ˆë‹¤.

## ğŸ“… ì˜ˆìƒ ê¸°ê°„: 3-4ì¼

## ğŸ¯ ì£¼ìš” ê³¼ì—…

### 1. íŒŒì¼ ì—…ë¡œë“œ ì‹œìŠ¤í…œ

**ëª©í‘œ:** ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ íŒŒì¼ ì—…ë¡œë“œ ë° ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„

#### êµ¬í˜„ í•­ëª©:

- [ ] **ë“œë˜ê·¸ ì•¤ ë“œë¡­:** ì§ê´€ì ì¸ íŒŒì¼ ì—…ë¡œë“œ UI
- [ ] **ë‹¤ì¤‘ íŒŒì¼ ì—…ë¡œë“œ:** ì—¬ëŸ¬ íŒŒì¼ ë™ì‹œ ì—…ë¡œë“œ
- [ ] **íŒŒì¼ ë¯¸ë¦¬ë³´ê¸°:** ì´ë¯¸ì§€, PDF, ë¬¸ì„œ ë¯¸ë¦¬ë³´ê¸°
- [ ] **ì§„í–‰ë¥  í‘œì‹œ:** ì‹¤ì‹œê°„ ì—…ë¡œë“œ ì§„í–‰ë¥ 
- [ ] **íŒŒì¼ ê²€ì¦:** íƒ€ì…, í¬ê¸°, ë°”ì´ëŸ¬ìŠ¤ ê²€ì‚¬
- [ ] **í´ë¼ìš°ë“œ ìŠ¤í† ë¦¬ì§€:** AWS S3 ë˜ëŠ” Supabase Storage ì—°ë™

#### íŒŒì¼ ì—…ë¡œë“œ ì»´í¬ë„ŒíŠ¸:

```typescript
// components/FileUpload.tsx
interface FileUploadProps {
  accept?: string;
  maxSize?: number;
  maxFiles?: number;
  onUpload: (files: File[]) => Promise<void>;
  className?: string;
}

export const FileUpload: FC<FileUploadProps> = ({
  accept = '*/*',
  maxSize = 10 * 1024 * 1024, // 10MB
  maxFiles = 5,
  onUpload,
  className
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [files, setFiles] = useState<File[]>([]);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    const droppedFiles = Array.from(e.dataTransfer.files);
    const validFiles = droppedFiles.filter(file => {
      if (file.size > maxSize) {
        toast.error(`File ${file.name} exceeds size limit`);
        return false;
      }
      return true;
    });

    if (validFiles.length > maxFiles) {
      toast.error(`Maximum ${maxFiles} files allowed`);
      return;
    }

    setFiles(prev => [...prev, ...validFiles].slice(0, maxFiles));
  }, [maxSize, maxFiles]);

  const handleUpload = async () => {
    if (files.length === 0) return;

    setUploading(true);
    setProgress(0);

    try {
      await onUpload(files);
      toast.success('Files uploaded successfully');
      setFiles([]);
    } catch (error) {
      toast.error('Upload failed');
    } finally {
      setUploading(false);
      setProgress(0);
    }
  };

  return (
    <div className={cn('file-upload', className)}>
      <div
        className={cn(
          'upload-zone',
          isDragging && 'dragging',
          uploading && 'uploading'
        )}
        onDrop={handleDrop}
        onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
        onDragLeave={() => setIsDragging(false)}
      >
        <Upload className="w-12 h-12 text-gray-400 mb-4" />
        <p className="text-gray-600">Drag and drop files here</p>
        <p className="text-sm text-gray-500">or click to browse</p>

        <input
          type="file"
          multiple
          accept={accept}
          className="hidden"
          onChange={(e) => {
            const selectedFiles = Array.from(e.target.files || []);
            setFiles(prev => [...prev, ...selectedFiles].slice(0, maxFiles));
          }}
        />
      </div>

      {files.length > 0 && (
        <div className="file-list">
          {files.map((file, index) => (
            <FileItem
              key={index}
              file={file}
              onRemove={() => setFiles(prev => prev.filter((_, i) => i !== index))}
            />
          ))}
        </div>
      )}

      {uploading && (
        <div className="upload-progress">
          <div className="progress-bar">
            <div
              className="progress-fill"
              style={{ width: `${progress}%` }}
            />
          </div>
          <span className="progress-text">{progress}%</span>
        </div>
      )}

      <Button
        onClick={handleUpload}
        disabled={files.length === 0 || uploading}
        className="w-full mt-4"
      >
        {uploading ? 'Uploading...' : 'Upload Files'}
      </Button>
    </div>
  );
};
```

#### Supabase Storage ì—°ë™:

```typescript
// lib/storage.ts
import { createClient } from '@/lib/supabase/client';

export class FileStorage {
  private supabase = createClient();

  async uploadFile(
    file: File,
    bucket: string = 'uploads',
    onProgress?: (progress: number) => void,
  ): Promise<string> {
    const fileName = `${Date.now()}-${file.name}`;
    const filePath = `${bucket}/${fileName}`;

    const { data, error } = await this.supabase.storage.from(bucket).upload(filePath, file, {
      cacheControl: '3600',
      upsert: false,
      onProgress: (progress) => {
        const percent = (progress.loaded / progress.total) * 100;
        onProgress?.(Math.round(percent));
      },
    });

    if (error) throw error;

    // ê³µê°œ URL ë°˜í™˜
    const {
      data: { publicUrl },
    } = this.supabase.storage.from(bucket).getPublicUrl(filePath);

    return publicUrl;
  }

  async deleteFile(path: string, bucket: string = 'uploads'): Promise<void> {
    const { error } = await this.supabase.storage.from(bucket).remove([path]);

    if (error) throw error;
  }

  async listFiles(bucket: string = 'uploads'): Promise<string[]> {
    const { data, error } = await this.supabase.storage.from(bucket).list();

    if (error) throw error;

    return data?.map((file) => file.name) || [];
  }
}
```

### 2. ì‹¤ì‹œê°„ ì•Œë¦¼ (WebSocket/SSE)

**ëª©í‘œ:** ì‚¬ìš©ìì—ê²Œ ì¦‰ê°ì ì¸ í”¼ë“œë°±ì„ ì œê³µí•˜ëŠ” ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ

#### êµ¬í˜„ í•­ëª©:

- [ ] **WebSocket ì—°ê²°:** ì–‘ë°©í–¥ ì‹¤ì‹œê°„ í†µì‹ 
- [ ] **Server-Sent Events:** ì„œë²„ í‘¸ì‹œ ì•Œë¦¼
- [ ] **ì•Œë¦¼ í:** ì•Œë¦¼ ë©”ì‹œì§€ í ê´€ë¦¬
- [ ] **ì˜¤í”„ë¼ì¸ ì§€ì›:** ì˜¤í”„ë¼ì¸ ì‹œ ì•Œë¦¼ ì €ì¥
- [ ] **ì•Œë¦¼ ì„¤ì •:** ì‚¬ìš©ìë³„ ì•Œë¦¼ ìˆ˜ì‹  ì„¤ì •
- [ ] **í‘¸ì‹œ ì•Œë¦¼:** ë¸Œë¼ìš°ì € í‘¸ì‹œ ì•Œë¦¼

#### WebSocket êµ¬í˜„:

```typescript
// lib/websocket.ts
export class WebSocketManager {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  private listeners: Map<string, Function[]> = new Map();

  connect(url: string) {
    try {
      this.ws = new WebSocket(url);

      this.ws.onopen = () => {
        console.log('WebSocket connected');
        this.reconnectAttempts = 0;
        this.emit('connected');
      };

      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.emit('message', data);

        // ì•Œë¦¼ íƒ€ì…ë³„ ì´ë²¤íŠ¸ ë°œìƒ
        if (data.type) {
          this.emit(data.type, data);
        }
      };

      this.ws.onclose = () => {
        console.log('WebSocket disconnected');
        this.emit('disconnected');
        this.reconnect();
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.emit('error', error);
      };
    } catch (error) {
      console.error('Failed to connect WebSocket:', error);
    }
  }

  private reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(
        () => {
          this.reconnectAttempts++;
          console.log(`Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
          this.connect(this.ws!.url);
        },
        this.reconnectDelay * Math.pow(2, this.reconnectAttempts),
      );
    }
  }

  send(data: any) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }

  on(event: string, callback: Function) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(callback);
  }

  off(event: string, callback: Function) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  private emit(event: string, data?: any) {
    const callbacks = this.listeners.get(event) || [];
    callbacks.forEach((callback) => callback(data));
  }

  disconnect() {
    this.ws?.close();
    this.ws = null;
  }
}
```

#### SSE êµ¬í˜„:

```typescript
// app/api/notifications/stream/route.ts
export async function GET(request: Request) {
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    start(controller) {
      const userId = request.headers.get('x-user-id');

      // ì‹¤ì‹œê°„ ì•Œë¦¼ ì „ì†¡
      const sendNotification = async (notification: Notification) => {
        const data = `data: ${JSON.stringify(notification)}\n\n`;
        controller.enqueue(encoder.encode(data));
      };

      // ë°ì´í„°ë² ì´ìŠ¤ ë³€ê²½ ê°ì§€
      const subscription = supabase
        .channel(`notifications:${userId}`)
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'notifications',
            filter: `user_id=eq.${userId}`,
          },
          (payload) => {
            sendNotification(payload.new);
          },
        )
        .subscribe();

      // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ ì‹œ ì •ë¦¬
      request.signal.addEventListener('abort', () => {
        subscription.unsubscribe();
        controller.close();
      });

      // ì´ˆê¸° ì•Œë¦¼ ì „ì†¡
      getUnreadNotifications(userId).then((notifications) => {
        notifications.forEach(sendNotification);
      });
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control',
    },
  });
}
```

### 3. ì˜ˆì•½ ì‹œìŠ¤í…œ ê¸°ë°˜ êµ¬ì¶•

**ëª©í‘œ:** ë¬¸ì˜ ì˜ˆì•½ ë° ìƒë‹´ ìŠ¤ì¼€ì¤„ë§ ì‹œìŠ¤í…œ êµ¬í˜„

#### êµ¬í˜„ í•­ëª©:

- [ ] **ìº˜ë¦°ë” ì»´í¬ë„ŒíŠ¸:** ë‚ ì§œ/ì‹œê°„ ì„ íƒ UI
- [ ] **ì˜ˆì•½ ìŠ¬ë¡¯:** ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ê´€ë¦¬
- [ ] **ì¤‘ë³µ ì˜ˆì•½ ë°©ì§€:** ì‹¤ì‹œê°„ ì˜ˆì•½ ìƒíƒœ ì²´í¬
- [ ] **ì˜ˆì•½ í™•ì¸:** ì´ë©”ì¼/SMS í™•ì¸
- [ ] **ìº˜ë¦°ë” ë™ê¸°í™”:** Google Calendar ì—°ë™
- [ ] **íƒ€ì„ì¡´ ì§€ì›:** ë‹¤êµ­ê°€ íƒ€ì„ì¡´ ì²˜ë¦¬

#### ì˜ˆì•½ ì‹œìŠ¤í…œ:

```typescript
// lib/booking.ts
export interface BookingSlot {
  id: string;
  startTime: Date;
  endTime: Date;
  available: boolean;
  consultantId: string;
}

export class BookingSystem {
  async getAvailableSlots(date: Date, consultantId?: string): Promise<BookingSlot[]> {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);

    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    // ê¸°ë³¸ ìŠ¬ë¡¯ ìƒì„± (30ë¶„ ê°„ê²©)
    const slots: BookingSlot[] = [];
    const slotDuration = 30 * 60 * 1000; // 30ë¶„

    for (let time = startOfDay.getTime(); time < endOfDay.getTime(); time += slotDuration) {
      const startTime = new Date(time);
      const endTime = new Date(time + slotDuration);

      // ì´ë¯¸ ì˜ˆì•½ëœ ìŠ¬ë¡¯ í™•ì¸
      const isBooked = await this.isSlotBooked(startTime, endTime, consultantId);

      slots.push({
        id: `${startTime.toISOString()}-${consultantId || 'any'}`,
        startTime,
        endTime,
        available: !isBooked,
        consultantId: consultantId || 'any',
      });
    }

    return slots;
  }

  async createBooking(
    slotId: string,
    customerInfo: CustomerInfo,
    type: 'consultation' | 'demo' | 'support',
  ): Promise<Booking> {
    // ìŠ¬ë¡¯ ê°€ìš©ì„± ì¬í™•ì¸
    const slot = await this.getSlotById(slotId);
    if (!slot.available) {
      throw new Error('Slot is no longer available');
    }

    // ì˜ˆì•½ ìƒì„±
    const booking = await supabase
      .from('bookings')
      .insert({
        slot_id: slotId,
        customer_info: customerInfo,
        type,
        status: 'pending',
        created_at: new Date().toISOString(),
      })
      .select()
      .single();

    // ìŠ¬ë¡¯ ìƒíƒœ ì—…ë°ì´íŠ¸
    await this.updateSlotAvailability(slotId, false);

    // í™•ì¸ ì´ë©”ì¼ ë°œì†¡
    await this.sendBookingConfirmation(booking.data);

    return booking.data;
  }

  async cancelBooking(bookingId: string, reason?: string): Promise<void> {
    const booking = await supabase
      .from('bookings')
      .update({
        status: 'cancelled',
        cancelled_at: new Date().toISOString(),
        cancellation_reason: reason,
      })
      .eq('id', bookingId);

    // ìŠ¬ë¡¯ ê°€ìš©ì„± ë³µì›
    await this.updateSlotAvailability(booking.slot_id, true);

    // ì·¨ì†Œ ì•Œë¦¼ ë°œì†¡
    await this.sendCancellationNotification(booking);
  }
}
```

### 4. ë‹¤êµ­ì–´ ì§€ì› ê¸°ë°˜

**ëª©í‘œ:** ê¸€ë¡œë²Œ í™•ì¥ì„ ìœ„í•œ ë‹¤êµ­ì–´ ì‹œìŠ¤í…œ êµ¬ì¶•

#### êµ¬í˜„ í•­ëª©:

- [ ] **i18n ì„¤ì •:** next-international ë˜ëŠ” next-i18next
- [ ] **ì–¸ì–´ íŒŒì¼:** JSON í˜•ì‹ ë²ˆì—­ íŒŒì¼
- [ ] **ì–¸ì–´ ì „í™˜:** ë™ì  ì–¸ì–´ ë³€ê²½
- [ ] **URL ë¼ìš°íŒ…:** ì–¸ì–´ë³„ ê²½ë¡œ êµ¬ì¡°
- [ ] **SEO ìµœì í™”:** hreflang íƒœê·¸, ì–¸ì–´ë³„ ë©”íƒ€ë°ì´í„°
- [ ] **RTL ì§€ì›:** ì•„ëì–´ ë“± ìš°ì¸¡ì—ì„œ ì¢Œì¸¡ ì–¸ì–´ ì§€ì›

#### i18n ì„¤ì •:

```typescript
// lib/i18n.ts
import { createI18nMiddleware } from 'next-international/middleware';
import { getRequestConfig } from 'next-international/server';

export const locales = ['ko', 'en', 'ja'] as const;
export const defaultLocale = 'ko' as const;

// ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
export const i18nMiddleware = createI18nMiddleware({
  locales,
  defaultLocale,
  urlMapping: {
    ko: '/',
    en: '/en',
    ja: '/ja',
  },
});

// ì„œë²„ ì„¤ì •
export const getRequestConfig = getRequestConfig(async ({ locale }) => ({
  messages: (await import(`../messages/${locale}.json`)).default,
}));

// íƒ€ì… ì •ì˜
export type Locale = (typeof locales)[number];
```

#### ì–¸ì–´ ì „í™˜ ì»´í¬ë„ŒíŠ¸:

```typescript
// components/LanguageSwitcher.tsx
'use client';

import { useLocale, useTranslations } from 'next-international';
import { useRouter, usePathname } from 'next/navigation';

export const LanguageSwitcher: FC = () => {
  const locale = useLocale();
  const router = useRouter();
  const pathname = usePathname();
  const t = useTranslations('common');

  const handleLanguageChange = (newLocale: string) => {
    const newPath = pathname.replace(`/${locale}`, `/${newLocale}`);
    router.push(newPath);
  };

  return (
    <div className="language-switcher">
      <select
        value={locale}
        onChange={(e) => handleLanguageChange(e.target.value)}
        className="px-3 py-2 border rounded"
      >
        <option value="ko">í•œêµ­ì–´</option>
        <option value="en">English</option>
        <option value="ja">æ—¥æœ¬èª</option>
      </select>
    </div>
  );
};
```

## ğŸ› ï¸ ê¸°ìˆ  êµ¬í˜„ ë°©ì•ˆ

### 1. íŒŒì¼ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸

```typescript
// lib/filePipeline.ts
export class FileProcessingPipeline {
  private storage = new FileStorage();
  private processor = new FileProcessor();

  async processFile(file: File, options: ProcessingOptions): Promise<ProcessedFile> {
    // 1. íŒŒì¼ ê²€ì¦
    await this.validateFile(file);

    // 2. ë°”ì´ëŸ¬ìŠ¤ ìŠ¤ìº”
    await this.scanForVirus(file);

    // 3. ì´ë¯¸ì§€ ìµœì í™” (ì´ë¯¸ì§€ì¸ ê²½ìš°)
    if (file.type.startsWith('image/')) {
      file = await this.processor.optimizeImage(file, options);
    }

    // 4. ìŠ¤í† ë¦¬ì§€ ì—…ë¡œë“œ
    const url = await this.storage.uploadFile(file);

    // 5. ì¸ë„¤ì¼ ìƒì„±
    const thumbnail = file.type.startsWith('image/')
      ? await this.processor.generateThumbnail(file)
      : null;

    return {
      originalUrl: url,
      thumbnailUrl: thumbnail,
      size: file.size,
      type: file.type,
      name: file.name,
    };
  }
}
```

### 2. ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë²„ìŠ¤

```typescript
// lib/eventBus.ts
export class EventBus {
  private events: Map<string, Function[]> = new Map();

  subscribe(event: string, callback: Function): () => void {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }

    this.events.get(event)!.push(callback);

    // êµ¬ë… í•´ì œ í•¨ìˆ˜ ë°˜í™˜
    return () => {
      const callbacks = this.events.get(event);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    };
  }

  publish(event: string, data?: any): void {
    const callbacks = this.events.get(event) || [];
    callbacks.forEach((callback) => callback(data));
  }

  unsubscribe(event: string): void {
    this.events.delete(event);
  }
}

// ì „ì—­ ì´ë²¤íŠ¸ ë²„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
export const eventBus = new EventBus();
```

## âœ… ì™„ë£Œ ê¸°ì¤€

### íŒŒì¼ ì—…ë¡œë“œ ê¸°ì¤€:

- [ ] 100MB íŒŒì¼ ì—…ë¡œë“œ ì§€ì›
- [ ] ë™ì‹œ 5ê°œ íŒŒì¼ ì—…ë¡œë“œ ê°€ëŠ¥
- [ ] ì—…ë¡œë“œ ì†ë„ 10MB/s ì´ìƒ
- [ ] íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° ëª¨ë“  í¬ë§· ì§€ì›

### ì‹¤ì‹œê°„ ê¸°ëŠ¥ ê¸°ì¤€:

- [ ] ì•Œë¦¼ 100ms ë‚´ ìˆ˜ì‹ 
- [ ] WebSocket ì—°ê²° ì•ˆì •ì„± 99.9%
- [ ] ì˜¤í”„ë¼ì¸ ì‹œ ì•Œë¦¼ í ì €ì¥
- [ ] ë™ì‹œ 1000ëª… ì ‘ì† ì§€ì›

### ì˜ˆì•½ ì‹œìŠ¤í…œ ê¸°ì¤€:

- [ ] ì˜ˆì•½ ì¶©ëŒ 0% ë°œìƒ
- [ ] ìº˜ë¦°ë” ë¡œë”© 500ms ì´ë‚´
- [ ] ì˜ˆì•½ í™•ì¸ 5ë¶„ ë‚´ ë°œì†¡
- [ ] íƒ€ì„ì¡´ ìë™ ë³€í™˜

### ë‹¤êµ­ì–´ ê¸°ì¤€:

- [ ] ì–¸ì–´ ì „í™˜ 100ms ì´ë‚´
- [ ] ëª¨ë“  í…ìŠ¤íŠ¸ ë²ˆì—­ ì™„ë£Œ
- [ ] SEO ìµœì í™” ëª¨ë“  ì–¸ì–´ ì ìš©
- [ ] RTL ì–¸ì–´ ì •í™•í•œ ë Œë”ë§

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„ ì¤€ë¹„

- 6ë‹¨ê³„ ìš´ì˜ íˆ´ì„ ìœ„í•œ ë°ì´í„° ë¶„ì„ ê¸°ë°˜ êµ¬ì¶•
- 7ë‹¨ê³„ ë¹„ì¦ˆë‹ˆìŠ¤ ê¸°ëŠ¥ì„ ìœ„í•œ ê²°ì œ ì‹œìŠ¤í…œ ì—°ë™ ì¤€ë¹„
- 8ë‹¨ê³„ í”„ë¡œë•ì…˜ ì¤€ë¹„ë¥¼ ìœ„í•œ ëª¨ë‹ˆí„°ë§ ì•„í‚¤í…ì²˜ ì„¤ê³„

---

_ë³¸ ë‹¨ê³„ê°€ ì™„ë£Œë˜ë©´ ê³ ê¸‰ ê¸°ëŠ¥ë“¤ì´ íƒ‘ì¬ë˜ì–´ ê²½ìŸë ¥ ìˆëŠ” í”Œë«í¼ì´ ì™„ì„±ë©ë‹ˆë‹¤_
