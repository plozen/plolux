파트너님, **[Step 5]**는 팬덤 플랫폼의 **가장 중요한 상호작용인 '투표(Voting)'** 기능을 구현하는 단계입니다. 단순히 버튼을 누르는 것을 넘어, 사용자에게 \*\*"내가 좋아하는 # [Step 5: 투표 시스템(Voting) 및 인터랙티브 모달 구현]

## 1. 목표

사용자가 회사를 지원할 수 있는 **투표(Support) 시스템**을 구현하고, 투표 성공 시 **화려한 인터랙션 효과(Confetti/Glow)**를 제공하여 사용자에게 명확한 피드백과 쾌감을 전달합니다.

# [Step 5: 홈 화면 투표 시스템 (Interactive Voting with Game Feel)]

## 1. 목표

홈 화면에서 사용자가 **선호하는 회사를 선택하고 투표 버튼을 클릭하면 점수가 증가**하는 게임 같은 투표 경험을 제공합니다. 회원은 자동 선택, 비회원은 수동 선택이 가능하며, **화려한 애니메이션 이펙트**로 게임의 쾌감을 극대화합니다.

---

## 2. 구현 요구사항

### [Task 1] 회사 선택 UI 구현

**파일**: `packages/kcl/src/components/features/home/CompanySelector/index.tsx`

#### 방식 1: 좌우 스크롤 카루셀 (권장)

- 화면 중앙에 현재 선택된 회사 표시 (크고 돋보이게)
- 좌우 화살표 버튼으로 회사 순회
- 스와이프 제스처 지원 (`framer-motion` drag)
- 부드러운 슬라이드 애니메이션
- 비활성 회사는 흐릿하게 표시

#### 방식 2: 검색 모달 팝업 (선택)

- "회사 검색" 버튼 클릭
- 모달 팝업에서 회사명 검색
- 검색 결과 클릭 시 선택 완료
- 파일: `packages/kcl/src/components/features/home/CompanySearchModal/index.tsx`

#### 설계

```typescript
interface CompanySelector {
  selectedCompanyId: string;
  onCompanyChange: (companyId: string) => void;
  isLoggedIn: boolean;
  userPreferredCompanyId?: string; // 회원의 선호 회사
}
```

**로직**:

- **회원**: `userPreferredCompanyId`로 자동 선택
- **비회원**: 첫 번째 회사가 기본 선택

---

### [Task 2] 투표 버튼 (Logo-Based)

**파일**: `packages/kcl/src/components/features/home/VoteButton/index.tsx`

#### UI 명세

- 선택된 회사의 **일러스트레이션/애니메이션 로고** (공식 로고 X)
- 로고 오른쪽에 **"여기를 클릭하세요 →"** 텍스트 + 화살표 아이콘
- 로고는 호버 시 약간 스케일 업 (`scale: 1.1`)
- 클릭 영역은 로고 자체

#### 로고 설계

- 각 회사별 커스텀 일러스트레이션 로고 생성
  - 하이브: 보라색 기하학적 모양
  - SM: 청색 동적 형태
  - YG: 검정 강렬한 패턴
  - JYP: 빨강 우아한 형태
  - 어도어: 분홍 미니멀 로고
  - 기타 등등
- 로고별 `src/public/logos/{companyId}-logo.svg` 저장

---

### [Task 3] 투표 액션 및 게임 이펙트

**파일**: `packages/kcl/src/app/[locale]/page.tsx` (수정) + 새 Hook

#### 투표 버튼 클릭 시 흐름

```
1. 로고 클릭
   ↓
2. 즉시 API 호출 (/api/vote)
   ↓
3. 점수 증가 (Redis: company:{id}:score += 100)
   ↓
4. 성공 응답 → 게임 이펙트 시작
```

#### 게임 이펙트 세트

**Effect 1: Confetti (폭죽 효과)**

- 로고 위치에서 색종이 터지는 애니메이션
- 라이브러리: `react-confetti` 또는 커스텀 구현
- 색상: 회사의 Primary Color 기반
- 지속 시간: 1초

**Effect 2: Score Popup (점수 팝업)**

- 로고 위에서 "+100" 텍스트가 위로 떠오르며 사라짐
- 폰트 크기: 큼 (3rem), bold
- 색상: Primary Color
- 애니메이션: `y: 0 → -80px`, `opacity: 1 → 0` (1초)

**Effect 3: Logo Glow (로고 강조)**

- 로고에 강렬한 Box Shadow 글로우
- 색상: Primary Color (밝기 조절)
- 지속 시간: 600ms (Pulse 효과)

**Effect 4: Haptic Feedback (선택)**

- 진동 피드백 (모바일): `navigator.vibrate(50)`
- 사운드 피드백 (선택): 짧은 "성공" 효과음

#### 구현 Hook

```typescript
// packages/kcl/src/hooks/useVote.ts
export function useVote() {
  const [isLoading, setIsLoading] = useState(false);
  const [lastVotedCompanyId, setLastVotedCompanyId] = useState<string | null>(null);

  const submitVote = async (companyId: string) => {
    setIsLoading(true);
    try {
      const res = await fetch('/api/vote', {
        method: 'POST',
        body: JSON.stringify({ companyId }),
        headers: { 'Content-Type': 'application/json' },
      });

      if (res.ok) {
        setLastVotedCompanyId(companyId);
        // 이펙트 발동
        triggerGameEffects(companyId);
      }
    } finally {
      setIsLoading(false);
    }
  };

  return { submitVote, isLoading };
}
```

---

### [Task 4] API 엔드포인트

**파일**: `packages/kcl/src/app/api/vote/route.ts`

#### 기능 명세

```typescript
POST / api / vote;
Request: {
  companyId: string;
}

Response: {
  success: boolean;
  currentScore: number; // 업데이트된 점수
  message: string;
}
```

#### 로직

1. **Redis Increment**: Key `company:{companyId}:score`를 `INCRBY 100`으로 증가
2. **Rate Limit**: 동일 IP 또는 사용자 ID로 **초당 1회만 허용** (스팸 방지)
3. **응답**: 현재 Redis 상의 점수 반환

#### 주의사항

- 회원 로그인 상태: 사용자 ID 기반 Rate Limit
- 비회원: IP 기반 Rate Limit
- Rate Limit 초과 시: `{ success: false, message: "너무 빨리 투표했습니다. 잠시 후 다시 시도하세요." }`

---

### [Task 5] 회원가입 연동

**파일들**:

- `packages/kcl/src/app/[locale]/page.tsx` (수정)
- `packages/kcl/src/lib/auth.ts` (또는 기존 auth 시스템)

#### 구현 사항

```typescript
// 회원 정보에 선호 회사 저장
interface User {
  id: string;
  preferredCompanyId: string; // 회원이 선택한 회사
  // ... 기타 필드
}

// 페이지 로드 시
useEffect(() => {
  if (isLoggedIn) {
    setSelectedCompanyId(user.preferredCompanyId);
  } else {
    setSelectedCompanyId(mockCompanies[0].id); // 첫 회사
  }
}, [isLoggedIn, user]);
```

#### UI 표시

- 로그인 상태: "🔒 자동 선택됨: [회사명]"
- 비회원: "회원가입하면 자동 선택됩니다"

---

## 3. 디자인 스펙

| 항목        | 설정                                      |
| ----------- | ----------------------------------------- |
| 카루셀      | Smooth Slide, 호버 시 Glow                |
| 로고        | 일러스트레이션 기반, 호버 시 `scale: 1.1` |
| Confetti    | 회사 Primary Color, 1초 지속              |
| Score Popup | 3rem bold, 위로 떠오르며 사라짐           |
| Logo Glow   | Primary Color, 600ms Pulse                |
| 텍스트      | "여기를 클릭하세요 →" (회사 로고 우측)    |

---

## 4. 중요 주의사항 ⚠️

### Locale 라우팅

```typescript
// API 호출 시 locale 불필요
// 페이지는 [locale]/page.tsx 내에서 구현
```

### 회사 선택 로직

```typescript
// 회원 로그인 여부 확인
const { user, isLoggedIn } = useAuth();

// 선택된 회사
const [selectedCompanyId, setSelectedCompanyId] = useState(
  isLoggedIn ? user.preferredCompanyId : mockCompanies[0].id,
);
```

### Rate Limit 처리

```typescript
// 클릭 시 버튼 비활성화 (1초)
const handleVote = async () => {
  setIsVoting(true);
  await submitVote(selectedCompanyId);
  setTimeout(() => setIsVoting(false), 1000);
};
```

### 이펙트 라이브러리

- **Confetti**: `react-confetti` npm 패키지
- **애니메이션**: `framer-motion` (기존)
- **사운드** (선택): `howler.js` 또는 HTML5 Audio API

---

## 5. 파일 생성 체크리스트

- [ ] `packages/kcl/src/components/features/home/CompanySelector/index.tsx`
- [ ] `packages/kcl/src/components/features/home/CompanySelector/CompanySelector.module.scss`
- [ ] `packages/kcl/src/components/features/home/VoteButton/index.tsx`
- [ ] `packages/kcl/src/components/features/home/VoteButton/VoteButton.module.scss`
- [ ] `packages/kcl/src/components/features/home/CompanySearchModal/index.tsx` (선택)
- [ ] `packages/kcl/src/components/features/home/GameEffects/index.tsx` (이펙트 통합)
- [ ] `packages/kcl/src/hooks/useVote.ts`
- [ ] `packages/kcl/src/app/api/vote/route.ts`
- [ ] `packages/kcl/src/public/logos/{companyId}-logo.svg` (각 회사별 7개)
- [ ] `packages/kcl/src/app/[locale]/page.tsx` (수정)

---

## 6. 데이터 흐름

```
홈 화면 로드
  ↓
회원 여부 확인
  ↓
회원: 선호 회사 자동 선택 / 비회원: 첫 회사 선택
  ↓
카루셀 또는 검색으로 회사 변경 (선택사항)
  ↓
로고 클릭
  ↓
API: POST /api/vote { companyId }
  ↓
Redis: company:{id}:score += 100
  ↓
게임 이펙트 발동 (Confetti + Score + Glow)
  ↓
점수 업데이트 반영
```

---

## 7. 다음 단계

[Step 4-2: 회사 상세 페이지 (탭 + 댓글)] 또는
[Step 6: 최종 점검 및 프로덕션 최적화]

---

## 2. 구현 요구사항

### [Task 1] 범용 모달 컴포넌트

**파일**: `packages/kcl/src/components/common/Modal/index.tsx`

#### 기능 명세

- Overlay: 반투명 검정 배경 (`backdrop-filter: blur(5px)`)
- Container: 화면 중앙에 위치하는 컨텐츠 박스
- Animation:
  - Overlay: `opacity: 0` → `1`
  - Content: `scale: 0.8, opacity: 0` → `scale: 1, opacity: 1` (Spring 효과)
- Props: `isOpen`, `onClose`, `title`, `children`

#### 디자인

- Glass Panel 스타일 적용 (`_mixins.scss`의 `glass-panel`)
- 버튼 배치: [Cancel(Ghost)] - [Confirm(Solid)] 순서
- Primary Color로 강조된 테두리

---

### [Task 2] 서포트 모달 구현

**파일**: `packages/kcl/src/components/features/vote/SupportModal/index.tsx`

#### 시나리오 흐름

```
1. 회사 상세 페이지에서 'Support' 버튼 클릭
   ↓
2. 확인 모달 팝업
   "OOO님에게 화력을 지원하시겠습니까?"
   ↓
3. '확인' 클릭 → API 호출 (/api/support)
   ↓
4. 성공 응답 →
   - 모달 닫힘
   - "Support Complete!" 메시지
   - 화려한 이펙트 발생 (Scale Up + Glow)
```

#### UI 명세

- 서포트 대상 회사명/로고 표시
- 확인/취소 버튼
- 성공 효과: Scale Up + Box Shadow Glow (Primary Color)

---

### [Task 3] 상태 연동

**파일들**:

- `packages/kcl/src/app/[locale]/company/[id]/page.tsx` (수정)
- `packages/kcl/src/app/[locale]/page.tsx` (수정)

#### 구현 사항

- `isSupportModalOpen` 상태 관리
- `selectedCompany` 상태 관리
- **Optimistic UI**: 투표 성공 시 즉시 점수 업데이트 (비동기 대기 없음)
- 성공 피드백: Toast 또는 인라인 메시지

---

### [Task 4] API 엔드포인트

**파일**: `packages/kcl/src/app/api/support/route.ts`

#### 기능 명세

```typescript
POST / api / support;
Request: {
  companyId: string;
  userId: string; // 선택사항 (예제용)
}

Response: {
  success: boolean;
  currentScore: number; // Redis에서 현재 값
  message: string;
}
```

#### 로직

1. **Redis Increment**: Key `company:{companyId}:score`를 `INCRBY 100` 으로 증가
2. **Rate Limit**: 동일 IP의 과도한 요청 방지
3. **응답**: 현재 Redis 상의 점수 반환

#### 주의사항

- 실제 DB 동기화는 [Step 6]에서 처리 (여기서는 Redis 적재만 완료)
- Upstash Redis 활용 가능

---

## 3. 디자인 스펙

| 항목               | 설정                                 |
| ------------------ | ------------------------------------ |
| Modal Overlay      | `blur(5px)` + 반투명 검정            |
| Modal Content      | Glass Panel + Primary Color 테두리   |
| Success Effect     | Scale Up + Box Shadow Glow (#8B5CF6) |
| Button Style       | Cancel(Ghost) - Confirm(Solid)       |
| Animation Duration | 300-500ms (Spring)                   |

---

## 4. 중요 주의사항 ⚠️

### Locale 라우팅 유지

```typescript
// API 호출 시 locale 정보는 필요 없음
// 단, 페이지 리다이렉트는 locale 포함

router.push(`/${locale}/company/${companyId}`);
```

### Mock 데이터 업데이트

- `mockVotes` 데이터와 실시간 점수 일치 필요
- Optimistic UI 적용 시 로컬 상태 먼저 업데이트 → API 호출

### 에러 처리

```typescript
try {
  const res = await fetch('/api/support', { method: 'POST', ... });
  if (!res.ok) throw new Error('Support failed');
  // Optimistic UI 유지 또는 롤백 처리
} catch (error) {
  // 사용자에게 에러 알림
  // Optimistic UI 롤백
}
```

---

## 5. 파일 생성 체크리스트

- [ ] `packages/kcl/src/components/common/Modal/index.tsx`
- [ ] `packages/kcl/src/components/common/Modal/Modal.module.scss`
- [ ] `packages/kcl/src/components/features/vote/SupportModal/index.tsx`
- [ ] `packages/kcl/src/components/features/vote/SupportModal/SupportModal.module.scss`
- [ ] `packages/kcl/src/app/api/support/route.ts`
- [ ] `packages/kcl/src/app/[locale]/company/[id]/page.tsx` (수정)
- [ ] 필요시 Hook 파일: `packages/kcl/src/hooks/useSupport.ts` (선택)

---

## 6. 데이터 흐름

```
UI Layer:
  회사 상세 페이지 → Support 버튼
    ↓
  SupportModal (확인 창)
    ↓
  API 호출
    ↓
  Optimistic UI 업데이트
    ↓
  성공 애니메이션

Server Layer:
  POST /api/support
    ↓
  Redis INCRBY company:{id}:score 100
    ↓
  Rate Limit 체크
    ↓
  JSON 응답 (현재 점수 포함)
```

---

## 7. 다음 단계

[Step 6: 최종 점검 및 프로덕션 최적화 (SEO & Deployment Prep)]아티스트를 1등으로 만들었다"\*\*는 확실한 피드백과 쾌감을 주어야 합니다.

이 프롬프트는 AI(Plolux)에게 **"재사용 가능한 모달(Modal) 시스템을 구축하고, 투표 성공 시 화려한 인터랙션(Confetti/Glow)을 제공하는 경험"**을 구현하도록 지시합니다.

아래 내용을 복사하여 AI에게 전달하십시오.

---

### **[Step 5: 투표 시스템(Voting) 및 인터랙티브 모달 구현]** 마스터 프롬프트

Markdown

#

`# 1. 현재 상황 및 목표 (Context & Goal)
우리는 [Step 4]까지 랭킹 리스트와 아티스트 상세 페이지를 구축하여 '조회' 기능을 완성했습니다.
이제 사용자가 실제로 참여할 수 있는 **서포트 시스템(Support System)**과 이를 위한 **모달(Modal) 인터페이스**를 구현해야 합니다.

당신의 목표는 다음 두 가지입니다.

1.  어디서든 호출 가능한 **범용 모달(Modal) 컴포넌트** 구현.
2.  Support(총공) 버튼 클릭 시 나타나는 **'서포트 확인 창'**과 성공 시의 **'화력 지원 효과(Firepower Effect)'** 구현.

---

# 2. 실행 가이드: 단계별 작업 지시 (Step-by-Step Instructions)

### [Task 1] 범용 모달 컴포넌트 (Common Modal)

모든 팝업의 기초가 되는 모달을 만드십시오. `framer-motion`의 `AnimatePresence`를 사용하여 부드럽게 등장하고 사라져야 합니다.

**파일 위치**: `src/components/common/Modal/` (index.tsx, Modal.module.scss)
**기능 및 UI 명세**:

- **Overlay**: 화면 전체를 덮는 반투명 검정 배경 (`backdrop-filter: blur(5px)`).
- **Container**: 화면 중앙(또는 하단)에 위치하는 컨텐츠 박스.
- **Animation**:
  - Overlay: `opacity: 0` -> `1`.
  - Content: `scale: 0.8, opacity: 0` -> `scale: 1, opacity: 1` (Spring 효과).
- **Interface**: `isOpen`, `onClose`, `title`, `children`을 Props로 받습니다.

### [Task 2] 서포트 기능 및 UI 구현 (Support Logic)

사용자가 Support 버튼을 눌렀을 때의 흐름을 구현하십시오. 상태 관리를 위해 `useState`를 사용합니다.

**구현 위치**: `src/components/features/vote/VoteModal/` (폴더명은 `SupportModal`로 변경 권장)
**시나리오**:

1.  **Trigger**: 랭킹 리스트나 상세 페이지의 'Support' 버튼 클릭.
2.  **Confirmation**: "OOO님에게 화력을 지원하시겠습니까?" 모달 팝업.
3.  **Action**: '확인' 클릭 시 `POST /api/support` 호출.
4.  **Success**: API 응답 성공 시 모달이 닫히면서 "Support Complete!" 메시지와 효과 발생.

### [Task 3] 상태 연동 (State Integration)

홈 화면(`src/app/page.tsx`)과 상세 페이지(`src/app/artist/[id]/page.tsx`)를 수정하여 모달을 연결하십시오.

- **State**: `isSupportModalOpen`, `selectedArtist` 상태를 상위 컴포넌트에서 관리.
- **Interaction**: 서포트 성공 시, 해당 아티스트의 화력(Firepower)이 즉시 `+100` 되는 **Optimistic UI(낙관적 업데이트)**를 적용하십시오.

### [Task 4] 서버 사이드 로직: Redis Batching (Backend)

트래픽 폭주 시 DB 비용을 방어하기 위해 **Upstash Redis**를 활용한 배칭 로직을 구현해야 합니다.

**파일 생성**: `src/app/api/support/route.ts`
**기능 명세**:

1. **Redis Increment**: 요청이 들어오면 DB에 바로 쓰지 않고 Redis의 Key(`artist:{id}:score`)를 `INCRBY`로 증가시킵니다.
2. **Rate Limit**: 동일 IP의 과도한 요청을 방지하는 간단한 로직을 추가하십시오.
3. **Response**: 200 OK와 함께 현재 감산된 Redis 상의 점수를 반환하십시오.
4. **(참고)**: 실제 DB 동기화(Cron Job)는 추후 단계에서 다루거나 별도 배치로 처리합니다. 여기서는 **Redis 적재**까지만 확실하게 구현하십시오.

---

# 3. 디자인 디테일 (Design Details)

- **Modal Style**: `_mixins.scss`의 `glass-panel`을 사용하여 고급스러운 유리 질감을 적용하십시오.
- **Button Group**: 모달 하단 버튼은 [Cancel(Ghost Type)] - [Confirm(Solid Type)] 순으로 배치하십시오.
- **Success Effect**: 투표 완료 순간, 아티스트의 이미지나 이름이 `Scale Up` 되며 Primary Color(#8B5CF6)로 강하게 빛나는(Box Shadow) 애니메이션을 추가하십시오.

---

# 4. 결과물 제출 요청 (Deliverables)

위 작업을 수행한 후, 다음 파일들의 **전체 코드**를 출력하십시오.

1.  `src/components/common/Modal/index.tsx` (범용 모달)
2.  `src/components/common/Modal/Modal.module.scss`
3.  `src/components/features/vote/SupportModal/index.tsx`
4.  `src/app/api/support/route.ts` (Redis 로직 포함)
5.  업데이트된 `src/app/page.tsx` (모달 연동)

지금 바로 사용자의 가슴을 뛰게 할 투표 시스템을 구현하십시오.`

---

[Next Step]

이 단계가 완료되면, 프로젝트의 마지막 단계인 [Step 6: 최종 점검 및 배포 준비(SEO, 메타데이터, 빌드 최적화)] 프롬프트를 준비해 드릴까요?
